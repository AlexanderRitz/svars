{
    "contents" : "#' Chow Test for Structural Break\n#'\n#' The Chow test is applied to a time series an presupposed point of structural break.\n#'\n#' @param Y Data\n#' @param SB integer. Structural break either of type integer as the number of observations which belong to the pre-break period or\n#'                    Date character. If a date character is provided, either a date Vector which contains the time line of the data\n#'                    in corresponding format or then the conventional time parameters need to be provided.\n#' @param nboot ??\n#' @param lags  Maximum number of Lag order\n#' @param dateVector vector. Vector of the time period concerned containing SB\n#' @param start character. Start of the time series (only if dateVector is empty)\n#' @param end character. End of the time series (only if dateVector is empty)\n#' @param frequency character. Frequency of the time series (only if dateVector is empty)\n#' @param format character. Date format (only if dateVector is empty)\n#' @return A list of results\n#'\n#' @export\n#'\n\n## Chow tests of system structural break ##\n#-----------------------------------------#\n\n# Y     : Data\n# SB    : Structural Break\n# nboot : number of Bootstrap iterations\n# lags  : maximum lag order\n\nchow.test <- function(Y, SB, nboot = 500, lags = 12, start = NULL, end = NULL,\n                      frequency = NULL, format = NULL, dateVector = NULL){\n  # Null Hypothesis of no Sample Split is rejected for large lambda\n\n  if(!is.numeric(SB)){\n\n    SB <- getStructuralBreak(SB = SB, start = start, end = end,\n                             frequency = frequency, format = format, dateVector = dateVector)\n  }\n\n\n  Full <- Y\n\n  # splitting sample\n  sample1 <- Y[1:SB, ]\n  sample2 <- Y[(SB+1):nrow(Y), ]\n\n  # selecting VAR orders\n  sel <- VARselect(Full, lag.max = lags)\n  if(any(sel$criteria[,sel$selection[1]] == -Inf) | any(is.na(sel$criteria[,sel$selection[1]]))){\n    sel$selection[1] <- sel$selection[1] - 2\n  }\n  if(sel$selection[1] == 1){\n    sel$selection[1] <- sel$selection[1] + 1\n  }\n\n  # estimating VAR for pre and post SB and for full series\n  VAR.model <- VAR(Full, p = sel$selection[1])\n  VAR1.model <- VAR(sample1, p = sel$selection[1])\n  VAR2.model <- VAR(sample2, p = sel$selection[1])\n\n  l1 <- VAR1.model$obs\n  l2 <- VAR2.model$obs\n  ll <- VAR.model$obs\n\n  # calculating three covariance matrices\n  Sigma.1 <- (1/l1)*t(residuals(VAR1.model))%*%(residuals(VAR1.model))\n  Sigma.2 <- (1/l2)*t(residuals(VAR2.model))%*%(residuals(VAR2.model))\n\n  Sigma <- (1/l1)*t(residuals(VAR.model)[1:l1,])%*%(residuals(VAR.model)[1:l1,]) +\n    (1/l2)*t(residuals(VAR.model)[(ll-l2+1):ll,])%*%(residuals(VAR.model)[(ll-l2+1):ll,])\n\n  # calculating the test statistic\n  # lambda_bp : teststatistic for break point (tests for change in covariance in addition)\n  # lambda_SP : teststatistic for structural break (tests only for parameter change)\n  lambda_bp <- (l1 + l2)*log(det(Sigma)) - l1*log(det(Sigma.1)) - l2*log(det(Sigma.2))\n  lambda_sp <- (l1 + l2)*(log(det(Sigma)) - log(det((1/(l1 + l2))*(l1*Sigma.1 + l2*Sigma.2))))\n\n\n    lambda_bpB <- rep(NA, nCboot)\n    lambda_spB <- rep(NA, nCboot)\n    TB <- l1\n\n    # bootstrapping the teststatistic to obtain empirical distribution\n    for(i in 1:nCboot){\n      A_hatF <- CoeffMat(VAR.model)\n      residF <- residuals(VAR.model)\n      BootDataF <- DataGen(A_hatF, Full, residF, sel$selection[1], TB)\n      BootData1 <- BootDataF[1:(l1+sel$selection[1]),]\n      BootData2 <- BootDataF[(l1+sel$selection[1]+1):nrow(BootDataF),]\n\n      VARB.model <- VAR(BootDataF, p = sel$selection[1])\n      VARB1.model <- VAR(BootData1, p = sel$selection[1])\n      VARB2.model <- VAR(BootData2, p = sel$selection[1])\n\n      Sigma.1 <- (1/l1)*t(residuals(VARB1.model))%*%(residuals(VARB1.model))\n      Sigma.2 <- (1/l2)*t(residuals(VARB2.model))%*%(residuals(VARB2.model))\n\n      Sigma <- (1/l1)*t(residuals(VARB.model)[1:l1,])%*%(residuals(VARB.model)[1:l1,]) +\n        (1/l2)*t(residuals(VARB.model)[(ll-l2+1):ll,])%*%(residuals(VARB.model)[(ll-l2+1):ll,])\n\n      lambda_bpB[i] <- (l1 + l2)*log(det(Sigma)) - l1*log(det(Sigma.1)) - l2*log(det(Sigma.2))\n      lambda_spB[i] <- (l1 + l2)*(log(det(Sigma)) - log(det((1/(l1 + l2))*(l1*Sigma.1 + l2*Sigma.2))))\n\n      progress(i, nCboot)\n    }\n\n    K <- VAR.model$K\n    df_bp <- sel$selection[1]*K^2 + K + (K*(K + 1))/2\n    df_sp <- sel$selection[1]*K^2 + K\n\n    # obtainind critical values an p-values for both tests\n    testcrit_bp <- quantile(lambda_bpB, probs = 0.95)\n    EmpDist_bp <- ecdf(lambda_bpB)\n    p.value_bp <- 1 - EmpDist_bp(lambda_bp)\n\n    testcrit_sp <- quantile(lambda_spB, probs = 0.95)\n    EmpDist_sp <- ecdf(lambda_spB)\n    p.value_sp <- 1 - EmpDist_sp(lambda_sp)\n\n    return(list(lambda_bp, testcrit_bp, p.value_bp,\n                lambda_sp, testcrit_sp, p.value_sp))\n\n}\n",
    "created" : 1483024514808.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2714331389",
    "id" : "B998554",
    "lastKnownWriteTime" : 1483024661,
    "path" : "~/GitHub/SVAR_Identification_Package/R/chow.test.R",
    "project_path" : "R/chow.test.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "type" : "r_source"
}