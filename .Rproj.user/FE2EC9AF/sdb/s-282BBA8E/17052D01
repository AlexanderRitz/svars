{
    "contents" : "#' Changes in Volatility Identification\n#'\n#' Identify B matrix based on changes in Volatility.\n#'\n#' @param x VAR-object. (S)VAR model to determine B matrix for\n#' @param SB integer. Structural break either of type integer as the number of observations which belong to the pre-break period or\n#'                    Date character. If a date character is provided, either a date Vector which contains the time line of the data\n#'                    in corresponding format or then the conventional time parameters need to be provided.\n#' @param dateVector vector. Vector of the time period concerned containing SB\n#' @param start character. Start of the time series (only if dateVector is empty)\n#' @param end character. End of the time series (only if dateVector is empty)\n#' @param frequency character. Frequency of the time series (only if dateVector is empty)\n#' @param format character. Date format (only if dateVector is empty)\n#' @return A list of results\n#'\n#' @export\n\n\n#--------------------------------------------#\n## Identification via changes in volatility ##\n#--------------------------------------------#\n\n# x  : object of class VAR\n# SB : Structural Break\n\n\nid.cv <- function(x, SB, start = NULL, end = NULL, frequency = NULL,\n                        format = NULL, dateVector = NULL){\n\n  if(!is.numeric(SB)){\n\n    SB <- getStructuralBreak(SB = SB, start = start, end = end,\n                             frequency = frequency, format = format, dateVector = dateVector)\n  }\n\n  u_t <- residuals(x)\n  p <- x$p\n  Tob <- x$obs\n  k <-x$K\n\n  TB <- SB - p\n\n  resid1 <- u_t[1:TB-1,]\n  resid2 <- u_t[TB:Tob,]\n  Sigma_hat1 <- (crossprod(resid1)) / (TB-1)\n  Sigma_hat2 <- (crossprod(resid2)) / (Tob-TB+1)\n\n  # Determine starting values for B and Lambda\n  B <- sqrtm((1/Tob)*crossprod(u_t)) + matrix(runif(k*k), nrow = k, byrow = T)\n  Lambda <- c(1,1,1)\n  S <- c(cbind(B, Lambda))\n\n  # optimize the likelihood function\n\n    MLE <- tryCatch(\n      optim(fn = LH, par = S, k = k, TB = TB, Sigma_hat1 = Sigma_hat1,\n                 Sigma_hat2 = Sigma_hat2, Tob = Tob, method = 'L-BFGS-B', hessian = T),\n    error = function(e) NULL)\n\n  if(!is.null(MLE)){\n    B_hat <- matrix(MLE$par[1:(k*k)], nrow = k)\n    Lambda_hat <- diag(MLE$par[(k*k+1):(k*k+k)])\n\n    # obtaining standard errors from inverse fisher information matrix\n    HESS <- solve(MLE$hessian)\n\n    for(i in 1:nrow(HESS)){\n      if(HESS[i,i] < 0){\n        HESS[,i] <- -HESS[,i]\n      }\n    }\n\n    FishObs <- sqrt(diag(HESS))\n    B.SE <- matrix(FishObs[1:(k*k)], k, k)\n    Lambda.SE <- FishObs[(k*k+1):(k*k+k)]*diag(k)\n  }\n\n    # ordering the columns with respect to the largest absolute values in each column\n    B_hat_ord <- matrix(0, k, k)\n    control <- rep(0, k)\n    for(i in 1:ncol(B_hat)){\n      for(j in 1:ncol(B_hat)){\n        if(which.max(abs(B_hat[, j])) == i){\n          if(control[i] == 0){\n            control[i] <- j\n            B_hat_ord[, i] <-B_hat[, j]\n          }else{\n            if(max(B_hat[, j]) > max(B_hat[, control[i]])){\n              control[i] <- j\n              B_hat_ord[, i] <-B_hat[, j]\n            }\n          }\n        }\n      }\n    }\n\n    # checking if any column in the orderd matrix is empty and replace it with the unused column in the estimated matrix\n    if(any(control == 0)){\n      hc <- sapply(1:k, function(x){any(x == control)})\n      B_hat_ord[, which(control == 0)] <- B_hat[, which(hc == FALSE)]\n      control[which(control == 0)] <- which(hc == FALSE)\n    }\n\n    # checking for negative values on the main daigonal\n    for(i in 1:ncol(B_hat_ord)){\n      if(B_hat_ord[i,i] < 0){\n        B_hat_ord[, i] <- B_hat_ord[, i]*(-1)\n      }\n    }\n\n    # reordering the lambda and S.E. matrices in the same way\n    B.SE <- B.SE[, control]\n    Lambda_hat <- diag(diag(Lambda_hat[, control]))\n    Lambda.SE <- diag(diag(Lambda.SE[, control]))\n\n  return(list(\n    Lambda = Lambda_hat,\n    Lambda_SE = Lambda.SE,\n    B = B_hat_ord,\n    B_SE = B.SE,\n    n = Tob,\n    Fish = HESS,\n    Lik = -MLE$value\n  ))\n}\n",
    "created" : 1483021986410.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2363808130",
    "id" : "17052D01",
    "lastKnownWriteTime" : 1483023610,
    "path" : "~/GitHub/SVAR_Identification_Package/R/id.cv.R",
    "project_path" : "R/id.cv.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}